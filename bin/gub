#!/usr/bin/python

"""
    Copyright (c) 2005--2007
    Jan Nieuwenhuizen <janneke@gnu.org>
    Han-Wen Nienhuys <hanwen@xs4all.nl>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
"""

import os
import re
import string
import sys
sys.path.insert (0, '.')
#
from gub import cross
## fixme: double use of gub name.
from gub import gubb
import gub.settings
from gub import misc
from gub import locker
from gub import gup

def get_cli_parser ():
    import optparse
    p = optparse.OptionParser ()

    p.usage='''gub [OPTION]... [PACKAGE]...

'''
    p.description='Grand Unified Builder.'

    p.add_option ('-B', '--branch', action='append',
                  dest='branches',
                  default=[],
                  metavar='NAME=BRANCH',
                  help='select branch')

    p.add_option ('-k', '--keep', action='store_true',
                  dest='keep_build',
                  default=None,
                  help='leave build and src dir for inspection')

    p.add_option ('-p', '--target-platform', action='store',
                  dest='platform',
                  type='choice',
                  default=None,
                  help='select target platform',
                  choices=gub.settings.platforms.keys ())

    p.add_option ('--inspect', action='store',
                  dest='inspect_key',
                  default=None,
                  help='Key of package to inspect')

    p.add_option ('--inspect-output', action='store',
                  dest='inspect_output',
                  default=None,
                  help='Where to write result of inspection')

    p.add_option ('--offline', action='store_true',
                  dest='offline',
                  help='Do not attempt to download anything')

    p.add_option ('--online', action='store_false',
                  dest='offline',
                  help='Download as part of the build')

    p.add_option ('--stage', action='store',
                  dest='stage', default=None,
                  help='Force rebuild of stage')

    p.add_option ('--fresh', action='store_true',
                  dest='fresh', default=False,
                  help='Restart all builds')

    p.add_option ('--cross-distcc-host', action='append',
                  dest='cross_distcc_hosts', default=[],
                  help='Add another cross compiling distcc host')

    p.add_option ('--native-distcc-host', action='append',
                  dest='native_distcc_hosts', default=[],
                  help='Add another native distcc host')

    p.add_option ('-v', '--verbose', action='count', dest='verbose', default=0)

    p.add_option ('--lilypond-versions', action='store',
                  default='uploads/lilypond.versions',
                  dest='lilypond_versions')

    p.add_option ('--force-package', action='store_true',
                  default=False,
                  dest='force_package',
                  help='allow packaging of tainted compiles' )

    p.add_option ('--build-source', action='store_true',
                  default=False,
                  dest='build_source',
                  help='build source packages')

    p.add_option ('--lax-checksums',
                  action='store_true',
                  default=False,
                  dest='lax_checksums',
                  help="do not rebuild packages with failing checksums")

    p.add_option ('-l', '--skip-if-locked',
                  default=False,
                  dest="skip_if_locked",
                  action="store_true",
                  help="Return successfully if another build is already running")

    p.add_option ('-j', '--jobs',
                  default="1", action='store',
                  dest='cpu_count',
                  help='set number of simultaneous jobs')

    return p

# FIXME: put all these functions that take manager, settings, specs, deps
# into a 'builder' class?
def pkg_checksum_valid (manager, spec, pkg):
    name = pkg.name ()
    pkg_dict = manager.package_dict (name)

    valid = (spec.spec_checksum == pkg_dict['spec_checksum']
             and spec.source_checksum () == pkg_dict['source_checksum'])

    hdr = pkg.expand ('%(split_hdr)s')
    valid = valid and os.path.exists (hdr)
    if valid:
        import pickle
        hdr_dict = pickle.load (open (hdr))
        hdr_sum = hdr_dict['spec_checksum']
        valid = valid and hdr_sum == spec.spec_checksum
        valid = valid and spec.source_checksum () == hdr_dict['source_checksum']

    ## let's be lenient for cross pkgs.
    ## spec.cross_checksum == manager.package_dict(name)['cross_checksum'])
    return valid
    

def spec_checksums_valid (manager, spec):
    valid = True
    for pkg in spec.get_packages ():
        valid = valid and pkg_checksum_valid (manager, spec, pkg)
    return valid

def run_one_builder (options, spec):
    import inspect
    available = dict (inspect.getmembers (spec, callable))
    if options.stage:
        (available[options.stage]) ()
        return
    
    stages = ['download', 'untar', 'patch',
              'configure', 'compile', 'install',
              'src_package', 'package', 'clean']

    if options.offline:
        stages.remove ('download')

    if not options.build_source:
        stages.remove ('src_package')

    if options.fresh:
        try:
            spec.os_interface.action ('Removing status filex')
            os.unlink (spec.get_stamp_file ())
        except OSError:
            pass

    tainted = False
    for stage in stages:
        if (not available.has_key (stage)):
            continue

        if spec.is_done (stage, stages.index (stage)):
            tainted = True
            continue

        spec.os_interface.stage (' *** Stage: %s (%s)\n'
                                 % (stage, spec.name ()))

        if stage == 'package' and tainted and not options.force_package:
            msg = spec.expand ('''Compile was continued from previous run.
Will not package.
Use

rm %(stamp_file)s

to force rebuild, or

--force-package

to skip this check.
''')
            spec.os_interface.error (msg)
            raise 'abort'


        if (stage == 'clean'
            and options.keep_build):
            os.unlink (spec.get_stamp_file ())
            continue

        try:
            (available[stage]) ()
        except misc.SystemFailed:

            ## failed patch will leave system in unpredictable state.
            if stage == 'patch':
                spec.system ('rm %(stamp_file)s')

            raise

        if stage != 'clean':
            spec.set_done (stage, stages.index (stage))

def spec_conflict_resolution (manager, spec, pkg):
    pkg_name = pkg.name ()
    install_candidate = pkg
    subname = ''
    if spec.name () != pkg_name:
        subname = pkg_name.split ('-')[-1]
    if spec.get_conflict_dict ().has_key (subname):
        for c in spec.get_conflict_dict ()[subname]:
            if manager.is_installed (c):
                print '%(c)s conflicts with %(pkg_name)s' % locals ()
                conflict_source = manager.source_name (c)
                # FIXME: implicit provides: foo-* provides foo-core,
                # should implement explicit provides
                if conflict_source + '-core' == pkg_name:
                    print ('  non-core %(conflict_source)s already installed'
                           % locals ())
                    print ('    skipping request to install %(pkg_name)s'
                           % locals ())
                    install_candidate = None
                    continue
                manager.uninstall_package (c)
    return install_candidate

def pkg_install (manager, spec, pkg):
    if not manager.is_installed (pkg.name ()):
        install_candidate = spec_conflict_resolution (manager, spec, pkg)
        if install_candidate:
            manager.unregister_package_dict (install_candidate.name ())
            manager.register_package_dict (install_candidate.dict ())
            manager.install_package (install_candidate.name ())
            
def spec_install (manager, spec):
    for pkg in spec.get_packages ():
        pkg_install (manager, spec, pkg)

def spec_build (settings, manager, specs, spec_name):
    spec = specs[spec_name]
    all_installed = True
    for p in spec.get_packages ():
        all_installed = all_installed and manager.is_installed (p.name ())
    if all_installed:
        return

    # ugh, dupe
    checksum_ok = (settings.options.lax_checksums
                   or spec_checksums_valid (manager, specs[spec_name]))

    is_installable = misc.forall (manager.is_installable (p.name ())
                                  for p in spec.get_packages ())

    if (settings.options.stage
        or not is_installable
        or not checksum_ok):
        settings.os_interface.stage ('building package: %s\n' % spec_name)
        run_one_builder (settings.options, spec)

    # FIXME, spec_install should be stage?
    if settings.options.stage: # and options.stage != spec_install:
        return

    # FIXME, spec_install should be stage?
    spec_install (manager, spec)

def uninstall_outdated_specs (settings, manager, specs, deps):
    def reverse (lst):
        list.reverse (lst)
        return lst
    for spec_name in reverse (deps[:]):
        spec = specs[spec_name]
        # ugh, dupe
        checksum_ok = (settings.options.lax_checksums
                       or spec_checksums_valid (manager, specs[spec_name]))
        for pkg in spec.get_packages ():
            if (manager.is_installed (pkg.name ())
                and (not manager.is_installable (pkg.name ())
                     or not checksum_ok)):
                manager.uninstall_package (pkg.name ())

def build_source_packages (settings, specs, names):
    try:
        manager = gup.get_target_manager (settings)

        ## Todo: have a readonly lock for local platform
    except locker.LockedError:
        print 'another build in progress. Skipping.'
        if settings.options.skip_if_locked:
            sys.exit (0)
        raise

    deps = filter (specs.has_key, names)

    PATH = os.environ['PATH']
    ## cross_prefix is also necessary for building cross packages, such as GCC
    os.environ['PATH'] = settings.expand ('%(cross_prefix)s/bin:' + PATH,
                                          locals ())

    ## UGH -> double work, see cross.change_target_packages () ?
    sdk_pkgs = [p for p in specs.values ()
                if isinstance (p, gubb.SdkBuildSpec)]
    cross_pkgs = [p for p in specs.values ()
                  if isinstance (p, cross.CrossToolSpec)]

    extra_build_deps = [p.name () for p in sdk_pkgs + cross_pkgs]
    gup.add_packages_to_manager (manager, settings, specs)

    # FIXME: what happens here, move to descriptive function?
    if not settings.options.stage:
        uninstall_outdated_specs (settings, manager, specs, deps)

    for spec_name in deps:
        spec_build (settings, manager, specs, spec_name)
        
def inspect (settings, files):
    (names, specs) = gup.get_source_packages (settings, files)
    pm = gup.get_target_manager (settings)
    gup.add_packages_to_manager (pm, settings, specs)
    deps = filter (specs.has_key, names)

    for f in files:
        v =  pm.package_dict (f)[settings.options.inspect_key]
        if settings.options.inspect_output:
            open (settings.options.inspect_output, 'w').write (v)
        else:
            print v
        
def build (settings, files):
    (names, specs) = gup.get_source_packages (settings, files)
    def get_all_deps (name):
        package = specs[name]
        deps = package.get_build_dependencies ()
        if not settings.is_distro:
            deps = [gup.get_base_package_name (d) for d in deps]
        return deps

    # FIXME: why do we only use deps for download, not for build?
    deps = gup.topologically_sorted (files, {}, get_all_deps, None)
    settings.os_interface.info ('deps:' + `deps` + '\n')

    PATH = os.environ['PATH']
    os.environ['PATH'] = settings.expand ('%(local_prefix)s/bin:' + PATH)

    if settings.options.stage == 'download':
        # FIXME: urg.  [only] For a real clean gub, with nothing in
        # downloads/, we cannot go into build process, and let stage
        # handle its own, as someone wants to create all spec
        # substitution dicts, and that needs certain source trees to
        # be already checked-out, eg ghostscript
        for i in deps:
            specs[i].download ()
        sys.exit (0)

    # FIXME: hw, why is this?  Doesn't this break 
    if settings.options.stage:
        names = files

    build_source_packages (settings, specs, names)

def main ():
    cli_parser = get_cli_parser ()
    (options, files) = cli_parser.parse_args ()

    if not options.platform:
        print 'error: no platform specified'
        cli_parser.print_help ()
        sys.exit (2)

    settings = gub.settings.Settings (options)

    if options.inspect_key:
        inspect (settings, files)
        sys.exit (0)

    try:
        build (settings, files)
        settings.os_interface.info ('done\n')
        settings.os_interface.info ('build log written to: ' +
                                    settings.os_interface.log_file_name
                                    + '\n')
    except SystemExit, e:
        sys.exit (e.code)
    except BaseException, e:
        if settings.options.verbose < settings.os_interface.level['output']:
            print >>sys.stderr,\
                (''.join (open (settings.os_interface.log_file_name)
                          .readlines ()[-50:]))
            log_file = settings.os_interface.log_file_name
        settings.os_interface.error (misc.exception_string (e))
        settings.os_interface.error ('build log written to: ' +
                                    settings.os_interface.log_file_name
                                    + '\n')
        sys.exit (1)

if __name__ == '__main__':
    main ()

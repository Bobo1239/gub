-*-Text-*-
Not committed yet.

[Log message beg]
Fix (TT font reader) : Allow 'post' over 65536 bytes.

DETAILS :

Bug 688154 "TTF file fails to load".

It applies .readbigtable to 'post' and then use new accessors
get_from_stringarray, getinterval_from_stringarray, string_array_size
to decode it.

The change should be algorithmically eqiovalent except for the 'post' size limitation.
A further optimizatrion of calls to first_post_string may be useful.

EXPECTED DIFFERENCES :

None.
[Log message end]
 
 
 
 
*** f:/casper/HEAD/gs/lib/gs_ttf.ps	Wed Jul 20 18:46:16 2005
--- files/gs/lib/gs_ttf.ps	Thu Aug  4 03:06:21 2005
***************
*** 451,454 ****
--- 451,510 ----
  } bind def
  
+ /get_from_stringarray % <array|string> <offset> get_from_stringarray <int>
+ { 1 index type /stringtype eq {
+     get
+   } {
+     exch {                % o ()
+       2 copy length gt {
+         length sub
+       } {
+         exch get exit
+       } ifelse
+     } forall
+   } ifelse
+ } bind def
+ 
+ /getinterval_from_stringarray % <array|string> <offset> <length> getinterval_from_stringarray <string>
+ { % May allocate a string in VM.
+   2 index type /stringtype eq {
+     getinterval
+   } {
+     string exch 0                                 % [] s o p
+     4 3 roll {                                    % s o p Si
+       dup length                                  % s o p Si lSi
+       dup 4 index lt {
+         3 index exch sub                          % s o p Si o'
+         exch pop 3 1 roll exch pop                % s o' p
+       } {                                         % s o p Si lSi
+         dup 3 1 roll                              % s o p lSi Si lSi
+         4 index sub                               % s o p lSi Si lSi-o
+         5 index length 4 index sub                % s o p lSi Si lSi-o ls-p
+         2 copy gt { exch } if pop                 % s o p lSi Si minl
+         dup 3 1 roll                              % s o p lSi minl Si minl
+         5 index exch getinterval                  % s o p lSi minl from
+         5 index 4 index 3 index                   % s o p lSi minl from s p minl
+         getinterval                               % s o p lSi minl from to
+         copy pop                                  % s o p lSi minl
+         3 1 roll                                  % s o minl p lSi
+         sub                                       % s o minl p'
+         3 1 roll add                              % s p' o'
+         dup 3 index length ge {
+           exch exit                               % s o p'
+         } if
+         exch                                      % s o' p'
+       } ifelse
+     } forall
+     pop pop                                       % s
+   } ifelse
+ } bind def
+ 
+ /string_array_size  % <array|string> string_array_size <int>
+ { dup type /stringtype eq {
+     length
+   } { 
+     0 exch { length add } forall
+   } ifelse
+ } bind def
+ 
  % Each procedure in this dictionary is called as follows:
  %       posttable <<proc>> glyphencoding
***************
*** 458,481 ****
    }
    16#00020000  {	% Detailed map, required by Microsoft fonts.
!     dup length 36 lt {
        TTFDEBUG { (post format 2.0 invalid.) = flush } if
        pop [ ]
      } {
      /postglyphs exch def
!       postglyphs 32 getu16 /numglyphs exch def
        /glyphnames numglyphs 2 mul 34 add def
        % Build names array in the order they occur in the 'post' table
        /postpos glyphnames def
        [ numglyphs 1 sub {
! 	postpos postglyphs length ge { exit } if
  	% No name available, /postnames will be defined as an empty
  	% array and the glyph won't get a name attached.
! 	postglyphs postpos get 
!         postglyphs postpos 1 add 2 index getinterval cvn
  	exch postpos add 1 add /postpos exch def
        } repeat
        ] /postnames exch def
        [ 0 1 numglyphs 1 sub {
! 	2 mul 34 add postglyphs exch getu16
  	dup 258 lt {
  	  MacGlyphEncoding exch get
--- 514,539 ----
    }
    16#00020000  {	% Detailed map, required by Microsoft fonts.
!     dup dup type /arraytype  eq { 0 get } if length 36 lt {
        TTFDEBUG { (post format 2.0 invalid.) = flush } if
        pop [ ]
      } {
        /postglyphs exch def
!       /post_first postglyphs dup type /arraytype eq { 0 get } if def
!       post_first 32 getu16 /numglyphs exch def
        /glyphnames numglyphs 2 mul 34 add def
        % Build names array in the order they occur in the 'post' table
        /postpos glyphnames def
+       /total_length postglyphs //string_array_size exec def
        [ numglyphs 1 sub {
! 	postpos total_length ge { exit } if
  	% No name available, /postnames will be defined as an empty
  	% array and the glyph won't get a name attached.
! 	postglyphs postpos //get_from_stringarray exec
!         postglyphs postpos 1 add 2 index //getinterval_from_stringarray exec cvn
  	exch postpos add 1 add /postpos exch def
        } repeat
        ] /postnames exch def
        [ 0 1 numglyphs 1 sub {
! 	2 mul 34 add post_first exch getu16
  	dup 258 lt {
  	  MacGlyphEncoding exch get
***************
*** 509,512 ****
--- 567,577 ----
  .dicttomark readonly def                % postformats
  
+ /call.readtable
+ { .readtable
+ } bind def
+ /call.readbigtable
+ { .readbigtable
+ } bind def
+ 
  % Each procedure in this dictionary is called as follows:
  %	<file> <length> -proc- <string|array_of_strings>
***************
*** 515,519 ****
  /readtables mark
  	% Ordinary tables
!   (cmap) { .readtable }
    (head) 1 index
    (hhea) 1 index
--- 580,584 ----
  /readtables mark
  	% Ordinary tables
!   (cmap) //call.readtable
    (head) 1 index
    (hhea) 1 index
***************
*** 521,533 ****
    (name) 1 index
    (OS/2) 1 index
!   (post) 1 index
!   (vhea) 1 index
  	% Big tables
!   (glyf) { .readbigtable }
    (loca) 1 index
    (hmtx) 1 index
    (vmtx) 1 index
  	% Tables only needed for embedding in PDF files
!   (cvt ) { .readtable }
    (fpgm) 1 index
    (prep) 1 index
--- 586,598 ----
    (name) 1 index
    (OS/2) 1 index
!   (post) //call.readbigtable
!   (vhea) //call.readtable
  	% Big tables
!   (glyf) //call.readbigtable
    (loca) 1 index
    (hmtx) 1 index
    (vmtx) 1 index
  	% Tables only needed for embedding in PDF files
!   (cvt ) //call.readtable
    (fpgm) 1 index
    (prep) 1 index
***************
*** 710,714 ****
    .readttdata
    /head tabdict /head get def
!   /post tabdict /post .knownget not { null } if def
    load_stripped not {
      /locatable tabdict /loca get def
--- 775,783 ----
    .readttdata
    /head tabdict /head get def
!   /post tabdict /post .knownget { 
!     dup 0 get /post_first_part exch def 
!   } { 
!     null 
!   } ifelse def
    load_stripped not {
      /locatable tabdict /loca get def
***************
*** 830,833 ****
--- 899,907 ----
  } bind def
  
+ /first_post_string % - first_post_string <string>
+ {
+   post dup type /arraytype eq { 0 get } if
+ } bind def
+ 
  % - .getpost -
  % Uses post, defines glyphencoding
***************
*** 836,843 ****
      TTFDEBUG { (post missing) = flush } if [ ]
    } {
!     postformats post 0 getu32 .knownget {
        TTFDEBUG {
  	(post: format ) print
! 	post 0 getu16 =only (,) print post 2 getu16 = flush
        } if
        post exch exec
--- 910,918 ----
      TTFDEBUG { (post missing) = flush } if [ ]
    } {
!     postformats first_post_string 0 getu32 .knownget {
        TTFDEBUG {
  	(post: format ) print
! 	first_post_string
! 	dup 0 getu16 =only (,) print 2 getu16 = flush
        } if
        post exch exec
***************
*** 875,882 ****
  		% Stack: ... /FontInfo mark key1 value1 ...
    post null ne {
!     /ItalicAngle post 4 gets32 65536.0 div
!     /isFixedPitch post 12 getu32 0 ne
!     /UnderlinePosition post 8 gets16 upem div
!     /UnderlineThickness post 10 gets16 upem div
    } if
    counttomark 0 ne { .dicttomark } { pop pop } ifelse
--- 950,957 ----
  		% Stack: ... /FontInfo mark key1 value1 ...
    post null ne {
!     /ItalicAngle first_post_string 4 gets32 65536.0 div
!     /isFixedPitch first_post_string 12 getu32 0 ne
!     /UnderlinePosition first_post_string 8 gets16 upem div
!     /UnderlineThickness first_post_string 10 gets16 upem div
    } if
    counttomark 0 ne { .dicttomark } { pop pop } ifelse
 
